;;; ifm-mode.el --- IFM editing commands for Emacs.
;;; Written by Glenn Hutchings (zondo42@googlemail.com)
;;;
;;; 21 Aug 2006 Lee Bigelow (ligelowbee@yahoo.com)
;;; Auto ifm-mode for .ifm files
;;; Added keys for postscript map output and viewing (with gv),
;;; task-list and item-list generation.
;;; Checks for errors when generating and jumps to lines when any
;;; are found.
;;; Keys:
;;; C-c C-c Generates postscript map file
;;; C-c C-t Generates text task-list file
;;; C-c C-i Generates text item-list file
;;; C-c C-v Starts gv in watch mode for postscript map file,
;;;         generates map first if not made already.  Once running
;;;         C-c C-c will keep it updated.

(defvar ifm-mode-map nil
  "Keymap used in IFM mode.")

(defvar ifm-mode-syntax-table nil
  "Syntax table used in IFM mode.")

(defvar ifm-mode-hook '())

(if ifm-mode-map
    nil
  (setq ifm-mode-map (make-sparse-keymap))
  (define-key ifm-mode-map "\t" 'indent-relative)
  (define-key ifm-mode-map "\C-c\C-c" 'ifm-make-ps-map)
  (define-key ifm-mode-map "\C-c\C-t" 'ifm-make-task-list)
  (define-key ifm-mode-map "\C-c\C-i" 'ifm-make-item-list)
  (define-key ifm-mode-map "\C-c\C-v" 'ifm-start-viewer))

(defconst ifm-structure-regexp
  (regexp-opt '("room") 'words)
  "Regexp matching structure keywords in IFM mode.")

(defconst ifm-direction-regexp
  (regexp-opt '("n" "north" "ne" "northeast" "e" "east" "se" "southeast"
		"s" "south" "sw" "southwest" "w" "west" "nw" "northwest")
	      'words)
  "Regexp matching direction names in IFM mode.")

(defconst ifm-special-regexp
  (regexp-opt '("endstyle" "style" "title" "map" "start" "finish" "safe"
		"require") 'words)
  "Regexp matching special keywords in IFM mode.")

(defconst ifm-builtin-regexp
  (regexp-opt '("all" "any" "it" "last" "none" "undef") 'words)
  "Regexp matching builtin names in IFM mode.")

(defconst ifm-keyword-regexp
  (regexp-opt '("after" "before" "cmd" "d" "do" "down" "dir" "drop" "except"
		"exit" "follow" "from" "get" "give" "go" "goto" "hidden"
		"ignore" "in" "item" "join" "keep" "leave" "length" "link"
		"lose" "lost" "need" "nodrop" "nolink" "nopath" "note"
		"oneway" "out" "score" "tag" "task" "to" "u" "up" "until"
		"with") 'words)
  "Regexp matching general keywords in IFM mode.")

(defconst ifm-obsolete-regexp
  (regexp-opt '("given" "times") 'words)
  "Regexp matching obsolete keywords in IFM mode.")

(defconst ifm-font-lock-keywords
  (list
   (cons "#.*" font-lock-comment-face)
   (cons "\"[^\"]*\"" font-lock-string-face)
   (cons ifm-special-regexp font-lock-constant-face)
   (cons ifm-structure-regexp font-lock-function-name-face)
   (cons ifm-direction-regexp font-lock-variable-name-face)
   (cons ifm-keyword-regexp font-lock-keyword-face)
   (cons ifm-builtin-regexp font-lock-builtin-face)
   (cons ifm-obsolete-regexp font-lock-warning-face))
  "Font-lock keywords in IFM mode.")

(defvar ifm-postscript-viewer "gv -watch"
  "*Program to view PostScript generated by IFM.

If possible, include an argument which causes the program to watch
for file updates.")

(add-hook 'ifm-mode-hook
	  (function (lambda ()
		      (make-local-variable 'font-lock-defaults)
		      (setq font-lock-defaults '(ifm-font-lock-keywords t)))))

(defun ifm-mode ()
  "Major mode for editing Interactive Fiction maps in IFM format.

As well as highlighting the IFM syntax, this mode can run IFM to
automatically generate the maps, item lists and task lists, and run a
PostScript viewer to view the maps.

\\{ifm-mode-map}

The PostScript viewer used is controlled by the 'ifm-postscript-viewer'
variable.  When the viewer is running, it tries to watch the generated
PostScript file for changes, so if you invoke \\[ifm-make-ps-map] again the
file will be redisplayed.

Calling this function invokes the function(s) listed in \"ifm-mode-hook\"
before doing anything else."
  (interactive)
  (kill-all-local-variables)
  (setq comment-start "# ")
  (setq comment-end "")
  (setq comment-column 0)
  (setq comment-start-skip "#[ \t]*")

  ;; Become the current major mode.
  (setq major-mode 'ifm-mode)
  (setq mode-name "IFM")

  ;; Activate syntax table.
  (if ifm-mode-syntax-table
      nil
    (setq ifm-mode-syntax-table (make-syntax-table))
    (modify-syntax-entry ?_ "w" ifm-mode-syntax-table))
  (set-syntax-table ifm-mode-syntax-table)

  ;; Activate keymap.
  (use-local-map ifm-mode-map)
  (run-hooks 'ifm-mode-hook))

(defun ifm-syntax-errors ()
  "Return line number of the first syntax error, or nil if none."
  (save-buffer)
  (shell-command (concat "ifm -f tk " (buffer-file-name)) "*ifm check*")
  (save-excursion
   (set-buffer "*ifm check*")
   (string-match "GotoLine \\([0-9]+\\).*" (buffer-string))
   (if (match-beginning 1)
       (string-to-int (substring (buffer-string) 
                                 (match-beginning 1) (match-end 1)))
     0)))

(defun ifm-make-ps-map ()
  "Create or update PostScript rendering of map."
  (interactive)
  (let ((error-line (ifm-syntax-errors))
         (bfname (buffer-file-name)) 
         (psfname (concat (buffer-file-name) ".ps")) )
    (if (> error-line 0)
          (goto-line error-line)
      (shell-command (concat "ifm -m -o " psfname " " bfname)))))

(defun ifm-make-item-list ()
  "Create or update item list file."
  (interactive)
  (let ((error-line (ifm-syntax-errors)) 
        (bfname (buffer-file-name)) 
        (ifname (concat (buffer-file-name) ".items.txt")))
    (if (> error-line 0)
        (goto-line error-line)
      (shell-command (concat "ifm -i -o " ifname " " bfname))
      (view-file-other-window ifname))))

(defun ifm-make-task-list ()
  "Create or update task list file."
  (interactive)
  (let ((error-line (ifm-syntax-errors)) 
        (bfname (buffer-file-name)) 
        (tfname (concat (buffer-file-name) ".tasks.txt")))
    (if (> error-line 0)
        (goto-line error-line)
      (shell-command (concat "ifm -t -o " tfname " " bfname))
      (view-file-other-window tfname))))

(defun ifm-start-viewer ()
  "Start PostScript viewer to view and watch the rendered map." 
  (interactive)
  (let ((error-line (ifm-syntax-errors)) 
        (psfname (concat (buffer-file-name) ".ps")) )
    (if (> error-line 0)
        (goto-line error-line)
      (if (file-exists-p psfname)
          (shell-command (concat ifm-postscript-viewer psfname " &"))
        (ifm-make-ps-map)
        (shell-command (concat ifm-postscript-viewer psfname " &"))))))

(defun ifm-mode-after-find-file ()
  (when (string-match "\\.ifm$" (buffer-file-name))
    (ifm-mode)))

(add-hook 'find-file-hooks 'ifm-mode-after-find-file)
(provide 'ifm-mode)
