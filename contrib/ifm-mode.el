;;; ifm-mode.el --- IFM editing commands for Emacs.
;;; 
;;; Originally written by Glenn Hutchings (zondo42@googlemail.com).
;;; Improved using code and ideas from Lee Bigelow (ligelowbee@yahoo.com).

(defvar ifm-program "ifm"
  "*IFM program to run.")

(defvar ifm-postscript-viewer "gv"
  "*Program to view PostScript generated by IFM.")

(defvar ifm-mode-map nil
  "Keymap used in IFM mode.")

(defvar ifm-mode-syntax-table nil
  "Syntax table used in IFM mode.")

(defvar ifm-mode-hook '())

(unless ifm-mode-map
  (setq ifm-mode-map (make-sparse-keymap))
  (define-key ifm-mode-map "\t" 'indent-relative)
  (define-key ifm-mode-map "\C-c\C-c" 'ifm-check-syntax)
  (define-key ifm-mode-map "\C-c\C-m" 'ifm-show-maps)
  (define-key ifm-mode-map "\C-c\C-i" 'ifm-show-items)
  (define-key ifm-mode-map "\C-c\C-t" 'ifm-show-tasks))

(defconst ifm-structure-regexp
  (regexp-opt '("room") 'words)
  "Regexp matching structure keywords in IFM mode.")

(defconst ifm-direction-regexp
  (regexp-opt '("n" "north" "ne" "northeast" "e" "east" "se" "southeast"
		"s" "south" "sw" "southwest" "w" "west" "nw" "northwest")
	      'words)
  "Regexp matching direction names in IFM mode.")

(defconst ifm-special-regexp
  (regexp-opt '("endstyle" "style" "title" "map" "start" "finish" "safe"
		"require") 'words)
  "Regexp matching special keywords in IFM mode.")

(defconst ifm-builtin-regexp
  (regexp-opt '("all" "any" "it" "last" "none" "undef") 'words)
  "Regexp matching builtin names in IFM mode.")

(defconst ifm-keyword-regexp
  (regexp-opt '("after" "before" "cmd" "d" "do" "down" "dir" "drop" "except"
		"exit" "follow" "from" "get" "give" "go" "goto" "hidden"
		"ignore" "in" "item" "join" "keep" "leave" "length" "link"
		"lose" "lost" "need" "nodrop" "nolink" "nopath" "note"
		"oneway" "out" "score" "tag" "task" "to" "u" "up" "until"
		"with") 'words)
  "Regexp matching general keywords in IFM mode.")

(defconst ifm-obsolete-regexp
  (regexp-opt '("given" "times") 'words)
  "Regexp matching obsolete keywords in IFM mode.")

(defconst ifm-font-lock-keywords
  (list
   (cons "#.*" font-lock-comment-face)
   (cons "\"[^\"]*\"" font-lock-string-face)
   (cons ifm-special-regexp font-lock-constant-face)
   (cons ifm-structure-regexp font-lock-function-name-face)
   (cons ifm-direction-regexp font-lock-variable-name-face)
   (cons ifm-keyword-regexp font-lock-keyword-face)
   (cons ifm-builtin-regexp font-lock-builtin-face)
   (cons ifm-obsolete-regexp font-lock-warning-face))
  "Font-lock keywords in IFM mode.")

(defun ifm-mode ()
  "Major mode for editing Interactive Fiction maps in IFM format.

As well as highlighting the IFM syntax, this mode can run IFM to
automatically generate the maps, item lists and task lists, and run a
PostScript viewer to view the maps.

\\{ifm-mode-map}

The PostScript viewer used is controlled by the 'ifm-postscript-viewer'
variable.

Calling this function invokes the function(s) listed in \"ifm-mode-hook\"
before doing anything else."
  (interactive)
  (kill-all-local-variables)

  (setq comment-start "# ")
  (setq comment-end "")
  (setq comment-column 0)
  (setq comment-start-skip "#[ \t]*")

  ;; Become the current major mode.
  (setq major-mode 'ifm-mode)
  (setq mode-name "IFM")

  ;; Activate syntax table.
  (unless ifm-mode-syntax-table
    (setq ifm-mode-syntax-table (make-syntax-table))
    (modify-syntax-entry ?_ "w" ifm-mode-syntax-table))

  (set-syntax-table ifm-mode-syntax-table)

  ;; Activate keymap.
  (use-local-map ifm-mode-map)
  (run-hooks 'ifm-mode-hook))

(defun ifm-show-maps (arg)
  "Display IFM maps in a PostScript viewer.
With prefix arg, write maps to PostScript file instead."
  (interactive "P")

  (ifm-check)
  (let ((file (ifm-get-filename "PostScript file" ".ps" arg)))
    ;; Write PostScript to file.
    (ifm-run "-map" " *ifm map*" file)

    ;; Feed it to viewer if required.
    (unless arg
      (start-process "PostScript viewer" nil ifm-postscript-viewer file))))

(defun ifm-show-items (arg)
  "Show IFM item list in another window.
With prefix arg, write item list to file instead."
  (interactive "P")
  (ifm-check)

  (let ((file (if arg
		  (ifm-get-filename "Item list file" "-items.txt" arg)
		nil)))
    (ifm-run "-items" "*IFM items*" file)))

(defun ifm-show-tasks (arg)
  "Show IFM task list in another window.
With prefix arg, write item list to file instead."
  (interactive "P")
  (ifm-check)

  (let ((file (if arg
		  (ifm-get-filename "Task list file" "-tasks.txt" arg)
		nil)))
    (ifm-run "-tasks" "*IFM tasks*" file)))

(defun ifm-get-filename (prompt suffix arg)
  "Get filename to write IFM output to."
  (let* ((dirname (file-name-directory (buffer-file-name)))
	 (bufname (file-name-nondirectory (buffer-file-name)))
	 (name (if bufname
		   (file-name-sans-extension bufname)
		 "untitled"))
	 (filename (concat name suffix))
	 (path (concat temporary-file-directory filename)))
    (if arg
	(read-file-name (concat prompt " (default " filename "): ")
			dirname filename)
      (concat temporary-file-directory filename))))

(defun ifm-check-syntax ()
  "Check syntax of IFM input in the current buffer."
  (interactive)
  (ifm-check)
  (message "Syntax appears OK"))

(defun ifm-check ()
  "Run IFM and check for syntax errors."
  ;; Run IFM in another buffer.
  (ifm-run "-" " *ifm check*" t)

  ;; Scan it for errors.
  (let ((line nil)
	(msg nil))
    (save-excursion
      (set-buffer " *ifm check*")
      (goto-char (point-min))
      (if (string-match "error: .+line \\([0-9]+\\): \\(.+\\)" (buffer-string))
	  (progn
	    (setq line (string-to-int (substring (buffer-string)
						 (match-beginning 1)
						 (match-end 1))))
	    (setq msg (substring (buffer-string)
				 (match-beginning 2) (match-end 2))))))

    ;; If error found, go to line and raise it.
    (if line
	(progn
	  (goto-line line)
	  (error "IFM error on line %d: %s" line msg)))))

(defun ifm-run (arg buf &optional file)
  "Run IFM on the current buffer.
Invoke it with the argument ARG and display output in buffer BUF.
If optional FILE is a string, write output to it.  Otherwise, display
results in a view window."
  ;; Kill any existing buffer.
  (if (get-buffer buf)
      (kill-buffer buf))

  ;; Run IFM on current buffer.
  (call-process-region (point-min) (point-max) ifm-program nil buf t arg)

  ;; Write or display buffer.
  (if (stringp file)
      (save-excursion
	(set-buffer buf)
	(write-region (point-min) (point-max) file nil 'novisit))
    (unless file
      (view-buffer buf)
      (goto-char (point-min)))))

(defun ifm-mode-after-find-file ()
  (when (string-match "\\.ifm$" (buffer-file-name))
    (ifm-mode)))

(add-hook 'find-file-hooks 'ifm-mode-after-find-file)

(add-hook 'ifm-mode-hook
	  (function (lambda ()
		      (make-local-variable 'font-lock-defaults)
		      (setq font-lock-defaults '(ifm-font-lock-keywords t)))))

(provide 'ifm-mode)
