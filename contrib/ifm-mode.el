;;; ifm-mode.el --- IFM editing commands for Emacs.

;;; Written by Glenn Hutchings (zondo42@googlemail.com)
;;; Enhanced by Lee Bigelow (ligelowbee@yahoo.com)

(defvar ifm-program "ifm"
  "*IFM program to run.")

(defvar ifm-postscript-viewer "gv"
  "*Program to view PostScript generated by IFM.")

(defvar ifm-mode-map nil
  "Keymap used in IFM mode.")

(defvar ifm-mode-syntax-table nil
  "Syntax table used in IFM mode.")

(defvar ifm-mode-hook '())

(unless ifm-mode-map
  (setq ifm-mode-map (make-sparse-keymap))
  (define-key ifm-mode-map "\t" 'indent-relative)
  (define-key ifm-mode-map "\C-c\C-c" 'ifm-show-maps)
  (define-key ifm-mode-map "\C-c\C-t" 'ifm-show-tasks)
  (define-key ifm-mode-map "\C-c\C-i" 'ifm-show-items))

(defconst ifm-structure-regexp
  (regexp-opt '("room") 'words)
  "Regexp matching structure keywords in IFM mode.")

(defconst ifm-direction-regexp
  (regexp-opt '("n" "north" "ne" "northeast" "e" "east" "se" "southeast"
		"s" "south" "sw" "southwest" "w" "west" "nw" "northwest")
	      'words)
  "Regexp matching direction names in IFM mode.")

(defconst ifm-special-regexp
  (regexp-opt '("endstyle" "style" "title" "map" "start" "finish" "safe"
		"require") 'words)
  "Regexp matching special keywords in IFM mode.")

(defconst ifm-builtin-regexp
  (regexp-opt '("all" "any" "it" "last" "none" "undef") 'words)
  "Regexp matching builtin names in IFM mode.")

(defconst ifm-keyword-regexp
  (regexp-opt '("after" "before" "cmd" "d" "do" "down" "dir" "drop" "except"
		"exit" "follow" "from" "get" "give" "go" "goto" "hidden"
		"ignore" "in" "item" "join" "keep" "leave" "length" "link"
		"lose" "lost" "need" "nodrop" "nolink" "nopath" "note"
		"oneway" "out" "score" "tag" "task" "to" "u" "up" "until"
		"with") 'words)
  "Regexp matching general keywords in IFM mode.")

(defconst ifm-obsolete-regexp
  (regexp-opt '("given" "times") 'words)
  "Regexp matching obsolete keywords in IFM mode.")

(defconst ifm-font-lock-keywords
  (list
   (cons "#.*" font-lock-comment-face)
   (cons "\"[^\"]*\"" font-lock-string-face)
   (cons ifm-special-regexp font-lock-constant-face)
   (cons ifm-structure-regexp font-lock-function-name-face)
   (cons ifm-direction-regexp font-lock-variable-name-face)
   (cons ifm-keyword-regexp font-lock-keyword-face)
   (cons ifm-builtin-regexp font-lock-builtin-face)
   (cons ifm-obsolete-regexp font-lock-warning-face))
  "Font-lock keywords in IFM mode.")

(defun ifm-mode ()
  "Major mode for editing Interactive Fiction maps in IFM format.

As well as highlighting the IFM syntax, this mode can run IFM to
automatically generate the maps, item lists and task lists, and run a
PostScript viewer to view the maps.

\\{ifm-mode-map}

The PostScript viewer used is controlled by the 'ifm-postscript-viewer'
variable.  When the viewer is running, it tries to watch the generated
PostScript file for changes, so if you invoke \\[ifm-make-ps-map] again the
file will be redisplayed.

Calling this function invokes the function(s) listed in \"ifm-mode-hook\"
before doing anything else."
  (interactive)
  (kill-all-local-variables)
  (setq comment-start "# ")
  (setq comment-end "")
  (setq comment-column 0)
  (setq comment-start-skip "#[ \t]*")

  ;; Become the current major mode.
  (setq major-mode 'ifm-mode)
  (setq mode-name "IFM")

  ;; Activate syntax table.
  (unless ifm-mode-syntax-table
    (setq ifm-mode-syntax-table (make-syntax-table))
    (modify-syntax-entry ?_ "w" ifm-mode-syntax-table))

  (set-syntax-table ifm-mode-syntax-table)

  ;; Activate keymap.
  (use-local-map ifm-mode-map)
  (run-hooks 'ifm-mode-hook))

(defun ifm-show-maps ()
  "Display IFM maps in a PostScript viewer."
  (interactive)

  ;; Generate PostScript in a buffer.
  (ifm-check)
  (ifm-run "-map" " *ifm map*" t)

  ;; Feed it to viewer.
  (save-excursion
    (set-buffer " *ifm map*")
    (let ((proc (start-process "PostScript viewer"
			       nil ifm-postscript-viewer "-")))
      (process-send-region proc (point-min) (point-max)))))

(defun ifm-show-items ()
  "Show IFM item list in another window."
  (interactive)
  (ifm-check)
  (ifm-run "-items" "*IFM items*"))

(defun ifm-show-tasks ()
  "Show IFM task list in another window."
  (interactive)
  (ifm-check)
  (ifm-run "-tasks" "*IFM tasks*"))

(defun ifm-check-syntax ()
  "Check syntax of IFM input in the current buffer."
  (interactive)
  (ifm-check)
  (message "Syntax appears OK"))

(defun ifm-check ()
  "Run IFM and check for syntax errors."
  ;; Run IFM in another buffer.
  (ifm-run "-" " *ifm check*" t)

  ;; Scan it for errors.
  (let ((line nil)
	(msg nil))
    (save-excursion
      (set-buffer " *ifm check*")
      (if (string-match "error: .+line \\([0-9]+\\): \\(.+\\)" (buffer-string))
	  (progn
	    (setq line (string-to-int (substring (buffer-string)
						 (match-beginning 1)
						 (match-end 1))))
	    (setq msg (substring (buffer-string)
				 (match-beginning 2) (match-end 2))))))

    ;; If error found, go to line and raise it.
    (if line
	(progn
	  (goto-line line)
	  (error "IFM error on line %d: %s" line msg)))))

(defun ifm-run (arg buf &optional noswitch)
  "Run IFM with the argument ARG and display output in buffer BUF."
  ;; Kill any existing buffer.
  (if (get-buffer buf)
      (kill-buffer buf))

  ;; Run IFM on current buffer.
  (call-process-region (point-min) (point-max) ifm-program nil buf t arg)

  ;; Switch to new buffer if required.
  (unless noswitch
    (view-buffer buf)
    (goto-char (point-min))))

(defun ifm-mode-after-find-file ()
  (when (string-match "\\.ifm$" (buffer-file-name))
    (ifm-mode)))

(add-hook 'find-file-hooks 'ifm-mode-after-find-file)

(add-hook 'ifm-mode-hook
	  (function (lambda ()
		      (make-local-variable 'font-lock-defaults)
		      (setq font-lock-defaults '(ifm-font-lock-keywords t)))))

(provide 'ifm-mode)

;;; Lee's stuff

(defun ifm-syntax-errors ()
  "Return line number of the first syntax error, or nil if none."
  (save-buffer)
  (shell-command (concat "ifm -f tk " (buffer-file-name)) "*ifm check*")
  (save-excursion
   (set-buffer "*ifm check*")
   (string-match "GotoLine \\([0-9]+\\).*" (buffer-string))
   (if (match-beginning 1)
       (string-to-int (substring (buffer-string) 
                                 (match-beginning 1) (match-end 1)))
     0)))

(defun ifm-make-ps-map ()
  "Create or update PostScript rendering of map."
  (interactive)
  (let ((error-line (ifm-syntax-errors))
         (bfname (buffer-file-name)) 
         (psfname (concat (buffer-file-name) ".ps")) )
    (if (> error-line 0)
          (goto-line error-line)
      (shell-command (concat "ifm -m -o " psfname " " bfname)))))

(defun ifm-make-item-list ()
  "Create or update item list file."
  (interactive)
  (let ((error-line (ifm-syntax-errors)) 
        (bfname (buffer-file-name)) 
        (ifname (concat (buffer-file-name) ".items.txt")))
    (if (> error-line 0)
        (goto-line error-line)
      (shell-command (concat "ifm -i -o " ifname " " bfname))
      (view-file-other-window ifname))))

(defun ifm-make-task-list ()
  "Create or update task list file."
  (interactive)
  (let ((error-line (ifm-syntax-errors)) 
        (bfname (buffer-file-name)) 
        (tfname (concat (buffer-file-name) ".tasks.txt")))
    (if (> error-line 0)
        (goto-line error-line)
      (shell-command (concat "ifm -t -o " tfname " " bfname))
      (view-file-other-window tfname))))

(defun ifm-start-viewer ()
  "Start PostScript viewer to view and watch the rendered map." 
  (interactive)
  (let ((error-line (ifm-syntax-errors)) 
        (psfname (concat (buffer-file-name) ".ps")) )
    (if (> error-line 0)
        (goto-line error-line)
      (if (file-exists-p psfname)
          (shell-command (concat ifm-postscript-viewer psfname " &"))
        (ifm-make-ps-map)
        (shell-command (concat ifm-postscript-viewer psfname " &"))))))
