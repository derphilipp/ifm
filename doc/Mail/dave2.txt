From dchapes@ddm.on.ca Mon Jun 22 08:02:02 1998
Received: from punt-11.mail.demon.net by hunting2.demon.co.uk with SMTP 
	id AA898527722 ; Mon, 22 Jun 98 08:02:02 PDT
Received: from punt-1.mail.demon.net by mailstore for zondo@hunting2.demon.co.uk
          id 898294027:10:12470:39; Fri, 19 Jun 98 22:07:07 GMT
Received: from p39a.neon.sentex.ca ([207.245.212.232]) by punt-1.mail.demon.net
           id aa1012930; 19 Jun 98 22:06 GMT
Received: from squigy.ddm.on.ca (squigy.ddm.on.ca [209.47.139.138])
	by ymris.ddm.on.ca (8.8.8/8.8.8) with ESMTP id SAA25378
	for <zondo@hunting2.demon.co.uk>; Fri, 19 Jun 1998 18:06:04 -0400 (EDT)
	(envelope-from dchapes@ymris.ddm.on.ca)
From: Dave Chapeskie <dchapes@ddm.on.ca>
Received: (from dchapes@localhost)
	by squigy.ddm.on.ca (8.8.8/8.8.7) id SAA00504;
	Fri, 19 Jun 1998 18:06:03 -0400 (EDT)
Message-ID: <19980619180603.38107@ddm.on.ca>
Date: Fri, 19 Jun 1998 18:06:03 -0400
To: Glen Hutchings <zondo@hunting2.demon.co.uk>
Subject: Re: ifm v1.0 patches for FreeBSD
References: <30@hunting2.demon.co.uk>
Mime-Version: 1.0
Content-Type: multipart/mixed; boundary=gKMricLos+KVdGMg
X-Mailer: Mutt 0.89i
In-Reply-To: <30@hunting2.demon.co.uk>; from Glenn Hutchings on Tue, Jun 16, 1998 at 05:05:46PM +0000
Return-Receipt-To: dchapes@ddm.on.ca
Status: R


--gKMricLos+KVdGMg
Content-Type: text/plain; charset=us-ascii

On Tue, Jun 16, 1998 at 05:05:46PM +0000, Glenn Hutchings wrote:
> I have to agree that the installation is not ideal.  At the moment I
> only have two machines to test it on.  I'm investigating autoconf and
> automake at the moment -- hopefully by the next release it'll all be
> nice and pain-free.

First releases are supposed to be non-ideal :-)

If you want me to test your next version on FreeBSD before you release
it then just let me know when the time comes.

> > Another potential improvement would be to allow one to specify items
> > that cannot be held, ie the opposite of the "need" clause.

> Hmm.  I've considered this before, I think, but couldn't find a
> feasible way to code it.  It'd be nice though.

I haven't looked at the code yet so I don't know how hard any of my
suggestions would be.


> > I haven't needed this yet but a task clause that says that not only is
> > an item needed but that it removes the item from play would be nice.
> > (ie "task ... destroys ItemTag")

> Not sure how useful it'd be, but certainly fairly easy to implement.

In many ways the same thing can be done by marking the item as "lost".
However it seems more logical to me to specify this with the task that
destroys/consumes/removes the item.

> > I'd love to see some more intelligence in the walk-through generator.
> So would I!

:-)


> I had dreams of a depth-first search of the whole task tree, but even
> a one-step lookahead takes long enough on a big map.

If it was easy to add, having this as an option would still be nice.
The default could be as it currently is but if someone ever wanted to
generate a more optimal solution they could crank up the option and let
it run for however many hours it needed.

Although the more I play with IFM the more I find that it's easy to
force a better order by artificially adding dependencies.  I usually add
a "not really" comment so that when I'm reviewing the file I can tell
which dependencies are which.

ie, from my Jigsaw.ifm file:
        task "light the fuse" need Sparkler score 1
                after Sketch1;	# not really

this prevents the walk-through from going to the monument and opening it
then going to the other side of the park to get the sketch materials,
making the sketch, and then returning to the opened monument.


> I'll be glad to put anything you want to send in a new release.  I've
> done the same thing in GNU Emacs, for my own amusement, which I might
> include.

I've attached the vim script file that I'm using.  Feel free to include
it if you want.


> Doing a stat() before drawing is probably the nicest method -- avoids
> having to select a 'reload' menu item every time.  Something else I
> hadn't considered, which sounds very useful.

Indeed.  The more I use tkifm and constantly select "Open" and my file
the more I want this :-)

If you wanted to be really external-editor-friendly you could provide a
read-only mode to tkifm (so that the edit window becomes just a browse
window) and when not in this mode flock(2) the file.  The flock(2) will
make vi (and I imagine emacs) warn you if you tried to edit the file
in both places.  If you wanted to go overboard you could even define a
command line to run to edit the file (ie so I could add:
'tk editor_cmd = "gvim %s"' to my ~/.ifmrc file or
'set ifm(editor) {gvim %s}' to my ~/.tkifmrc file)


> Finally... thanks a lot for all the comments!  Such is the way
> that improvements and new versions are made.

No problem.  It's already a great program as is.  On a whim I booted
into winbloze and tried GUEmap from the if-archive.  If I hadn't seen
IFM I might have thought is was okay but after playing with IFM I just
think GUEmap is a poor-man's mapper :-)  And to think the author of
GUEmap wants people to pay him $10 for it too!

> If you have any more suggestions, I'd like to hear them.

Well I did notice that the "drop" messages are sometimes generated too
early.  For example:

room "room #1" tag Room1;
item "test item" tag Item1;
task "do something" need Item1 goto Room2;
room "room #2" tag Room2;

produces:

room #1:
   Get test item
   do something
   Drop test item

Whereas I expected the "Drop test item" message to be listed under "room
#2".  This of course is a really minor nitpick.


I've also noticed that curved connection lines don't always do what I
suspect.  For example if I do:

room "south room" tag SRoom;
room "north room" tag NRoom dir n;
link SRoom to NRoom dir e nw;
link SRoom to NRoom dir w ne;

(this actually did come up in a game I was mapping since the "north
room" was a larger area that surrounded the "south room").  This
produces two warnings and the lines don't connect exactly at the corners
of the north room.  This is another nitpick in that I can just ignore
the warning, the lines are close enough for me.

What might be useful is a way to tell the system that I know the link
will cross were it shouldn't and I don't want to be told.  Ie:

link SRoom to NRoom dir e ne nowarn;

Either that or a way to make larger room squares or even non-rectangular
rooms.  Although I imagine this would be hard to implement.


Also I've noticed that tkifm has a tendency to add "./" to the front
of relative pathnames.  After reloading my file several times it was
using the filename "./././././././Jigsaw.ifm".  This is another minor
nit (until the path get longer than MAX_PATHSIZE and fails to work).
One solution would be to always convert the path to an absolute path.


And finally, although not a suggestion for IFM you may still be
interested in this:

I've been thinking of adding an "automap" library for inform which uses
IFM.  I'm thinking along the lines of having an "ifm_line" property
for all objects and rooms (actually the room one could probably be
auto-generated for most rooms from the "n_to", "e_to", etc properties).
Then the library would append these lines to a file the first time
you visit a room or see an object.  Also a routine that prints out an
task IFM line (only the first time it's called with given arguments,
ala Inform's Achieved() function).  The idea would be to have the game
generate an IFM file only showing rooms/items/tasks that you've already
seen and done.  I know the z-machine can write to text files other than
save files but I've never looked at the details so I don't know how hard
this will be.

When playing a game using this library the player could run tkifm on
the games map file and see the latest greatest map as they play (if you
automatically check the file for changes as mentioned above).  For some
games this would be better than providing an IFM file (or other format
map) with the game since sometimes just knowing were certain rooms are
can spoil a puzzle (ie if you know there is a secret passage to the
north...).

-- 
Dave Chapeskie <dchapes@ddm.on.ca>, DDM Consulting

--gKMricLos+KVdGMg
Content-Type: text/plain; charset=us-ascii
Content-Description: VIM syntax highlighting for IFM
Content-Disposition: attachment; filename="ifm.vim"

" IFM syntax file
" Language: Interactive Fiction Mapper
" Maintainer: Dave Chapeskie <dchapes@ddm.on.ca>
" Last change: Tue Jun 16 04:19:57 EDT 1998
"
" Note:  This is my first attempt at doing vim syntax highlighting,
"        if there is a better way of doing any of this please e-mail me.

" Remove any old syntax stuff hanging around
syntax clear

" Catch keywords in the wrong spot
syntax keyword ifmError contained title map room item task link join

" IFM statements
" TODO: doesn't complain when there is something betweem the keyword and the string
syntax region ifmTitleStatement	end=";" matchgroup=ifmStatement start="\<title\>" contains=ifmError,ifmComment,ifmString
syntax region ifmMapStatement	end=";" matchgroup=ifmStatement start="\<map\>" contains=ifmError,ifmComment,ifmString
syntax region ifmRoomStatement	end=";" matchgroup=ifmStatement start="\<room\>" contains=ifmError,ifmComment,ifmString,ifmRoomOpt,ifmTagOpt,ifmDirFromOpt,ifmExitOpt,ifmScoreOpt,ifmGoOpt
syntax region ifmItemStatement	end=";" matchgroup=ifmStatement start="\<item\>" contains=ifmError,ifmComment,ifmString,ifmItemOpt,ifmTagOpt,ifmScoreOpt
syntax region ifmTaskStatement	end=";" matchgroup=ifmStatement start="\<task\>" contains=ifmError,ifmComment,ifmString,ifmTaskOpt,ifmTagOpt,ifmScoreOpt
syntax region ifmLinkStatement	end=";" matchgroup=ifmStatement start="\<link\>" contains=ifmError,ifmComment,ifmString,ifmLinkOpt,ifmTagOpt,ifmDirOpt,ifmGoOpt
syntax region ifmJoinStatement	end=";" matchgroup=ifmStatement start="\<join\>" contains=ifmError,ifmComment,ifmString,ifmJoinOpt,ifmTagOpt,ifmDirOpt,ifmGoOpt

" Comments
syntax match ifmComment "#.*" contains=ifmTodo
syntax keyword ifmTodo	contained TODO XXX


" Arguments of options which we want highlighted
syntax keyword ifmGoDir contained out in up down
" TODO: ifmString doesn't handle "testStr\\" correctly...
syntax region ifmString	contained start=+"+ skip=+\\"+ end=+"+
syntax match ifmId	contained "[a-zA-Z][a-zA-Z0-9_]\+"
syntax match ifmInteger	contained "[0-9]\+"
syntax match ifmReal	contained "[0-9]\+\.[0-9]\+"

" The options which the above arguments are part of
syntax region ifmTagOpt	contained end="\<\S*\>" matchgroup=ifmKeyword start="\<tag\>" contains=ifmId keepend
syntax region ifmScoreOpt contained end="\<[0-9]*\>" matchgroup=ifmKeyword start="\<score\>" contains=ifmInteger keepend
syntax region ifmGoOpt	contained end="\<\S*\>" matchgroup=ifmKeyword start="\<go\>" contains=ifmGoDir keepend

syntax keyword ifmExitOpt	contained exit			skipwhite skipempty nextgroup=ifmDir
syntax keyword ifmDirOpt	contained dir			skipwhite skipempty nextgroup=ifmDir
syntax keyword ifmDirFromOpt	contained dir			skipwhite skipempty nextgroup=ifmDirFrom
syntax keyword ifmDir		contained nw n ne w e sw s se	skipwhite skipempty nextgroup=ifmDir
syntax keyword ifmDirFrom	contained nw n ne w e sw s se	skipwhite skipempty nextgroup=ifmDirFrom,ifmFromOpt
syntax keyword ifmFromOpt       contained from


" Other options:
"    These options take arguments but we don't hightlight them
"    TODO: "in last" should have the word 'last' highlighted as a constant
"    similarily for tasks "in any" should have 'any' highlighted
syntax keyword ifmRoomOpt contained link join need after note 
syntax keyword ifmItemOpt contained need after note in
syntax keyword ifmTaskOpt contained note need after get goto in
syntax keyword ifmLinkOpt contained to need after
syntax keyword ifmJoinOpt contained to need after
"    These options don't have arguments
syntax keyword ifmRoomOpt contained start oneway puzzle special
syntax keyword ifmItemOpt contained hidden keep given lost
syntax keyword ifmLinkOpt contained oneway special
syntax keyword ifmJoinOpt contained oneway


" IFM variable assignment
" [Format] [Type] Ident = Integer|Real|String ;
" TODO: doesn't handle 'Type' being specified without 'Format'
syntax region ifmEqInt contained end=";" matchgroup=ifmStatement start="=" contains=ifmInteger
syntax region ifmEqReal contained end=";" matchgroup=ifmStatement start="=" contains=ifmInteger,ifmReal
syntax region ifmEqString contained end=";" matchgroup=ifmStatement start="=" contains=ifmString

syntax keyword ifmIntIdent map_width map_height show_title show_border show_items link_spline show_date show_pagenum fill_notes skipwhite skipempty nextgroup=ifmEqInt
syntax keyword ifmRealIdent page_width page_height page_margin title_fontsize map_fontsize room_fontsize room_width room_height room_size room_shading room_linewidth item_fontsize exit_linewidth link_linewidth label_fontsize map_scale note_width line_width skipwhite skipempty nextgroup=ifmEqReal
syntax keyword ifmStringIdent prolog_file title_font map_font room_font item_font label_font map_colour room_puzzle_colour exit_colour link_special_colour label_colour skipwhite skipempty nextgroup=ifmEqString

syntax keyword ifmType contained map item task skipwhite skipempty nextgroup=ifmIntIdent,ifmRealIdent,ifmStringIdent
syntax keyword ifmFormat ps tk groff skipwhite skipempty nextgroup=ifmType,ifmIntIdent,ifmRealIdent,ifmStringIdent


" Syncronization.
" Look backwards for a ';' but ignore any that occur in comments or
" strings.  Stop after going back 250 lines without finding a ';'
syntax sync match ifmSyncRoutine grouphere NONE ";"
syntax sync match ifmNoSyncComment "#.*"
syntax sync region ifmNoSyncString start=+"+ skip=+\\"+ end=+"+
syntax sync maxlines=250


if !exists("did_ifm_syntax_inits")
  let did_ifm_syntax_inits = 1
  " The default methods for highlighting.  Can be overridden later
  highlight link ifmStatement	Statement
  highlight link ifmRoomOpt	ifmKeyword
  highlight link ifmItemOpt	ifmKeyword
  highlight link ifmTaskOpt	ifmKeyword
  highlight link ifmLinkOpt	ifmKeyword
  highlight link ifmJoinOpt	ifmKeyword
  highlight link ifmExitOpt	ifmKeyword
  highlight link ifmDirOpt	ifmKeyword
  highlight link ifmDirFromOpt	ifmKeyword
  highlight link ifmFromOpt	ifmKeyword
  highlight link ifmKeyword	Type
  highlight link ifmGoDir	ifmDir
  highlight link ifmDirFrom	ifmDir
  highlight link ifmDir		Constant
  highlight link ifmInteger	Number
  highlight link ifmReal	Number
  highlight link ifmError	Error
  highlight link ifmString	String
  highlight link ifmComment	Comment
  highlight link ifmTodo	Todo
  highlight	 ifmId		term=bold cterm=bold gui=bold
  highlight link ifmFormat	ifmType
  highlight link ifmType	Type
  highlight link ifmIntIdent	ifmIdent
  highlight link ifmRealIdent	ifmIdent
  highlight link ifmStringIdent	ifmIdent
  highlight link ifmIdent	Identifier
endif

let current_syntax = "ifm"

" ifm: ts=8

--gKMricLos+KVdGMg--

