#! /usr/local/bin/perl

### scr2ifm -- convert game transcript to IFM

use Getopt::Std;

# Compass direction command -> direction mapping.
%cdirmap = ("N" => "n", "NORTH" => "n", "NE" => "ne", "NORTHEAST" => "ne",
	    "E" => "e", "EAST" => "e", "SOUTHEAST" => "se", "SE" => "se",
	    "SOUTH" => "s", "S" => "s", "SOUTHWEST" => "sw", "SW" => "sw",
	    "WEST" => "w", "W" => "w", "NORTHWEST" => "nw", "NW" => "nw");

# Other direction command -> direction mapping.
%odirmap = ("UP" => "up", "U" => "up", "DOWN" => "down", "D" => "down",
	    "IN" => "in", "OUT" => "out");

# Reverse-direction mapping.
%rdirmap = ("n" => "s", "s" => "n", "ne" => "sw", "sw" => "ne", "e" => "w",
	    "w" => "e", "se" => "nw", "nw" => "se", "in" => "out",
	    "out" => "in", "up" => "down", "down" => "up");

# Clockwise-direction mapping.
%cwmap = ("n" => "ne", "ne" => "e", "e" => "se", "se" => "s", "s" => "sw",
	  "sw" => "w", "w" => "nw", "nw" => "n");

# Anticlockwise-direction mapping.
%acwmap = ("n" => "nw", "nw" => "w", "w" => "sw", "sw" => "s", "s" => "se",
	   "se" => "e", "e" => "ne", "ne" => "n");

# List of transcript moves (hash entries).
@moves = ();

# Room tag -> room data mapping.
%roommap = ();

# Room name -> list-of-room-tags mapping.
%namemap = ();

# Room description -> list-of-room-tags mapping.
%descmap = ();

# List of IFM rooms.
@rooms = ();

# List of IFM links.
@links = ();

# Default regexps.
$re_prompt = '^>\s*';
$re_look = '^L(OOK)?';
$re_end = '^UNSCRIPT';

### Stage 1 -- parse arguments and read input.

# Parse arguments.
&getopts('hi:o:t:v') or die "Type `$0 -h' for help\n";
&usage if $opt_h;

# Read extra IFM commands if required.
if ($opt_i) {
    open(IFM, $opt_i) or die "Can't open $opt_i: $!\n";
    @ifmcmds = <IFM>;
    close IFM;
}

# Redirect stdout if required.
if ($opt_o) {
    open(STDOUT, "> $opt_o") or die "Can't open $opt_o: $!\n";
}

# Skip input until first prompt.
while (<>) {
    last if /$re_prompt/o;
}

# Read prompt/command/reply blocks.
while (1) {
    # Get command.
    s/$re_prompt//o;
    chop($cmd = uc $_);
    $cmd =~ s/\s+$//;

    # Check for end of script.
    last if $cmd =~ /$re_end/o;

    # Read reply.
    $reply = [];
    while (<>) {
	last if /$re_prompt/o;
	chop;
	push(@$reply, $_);
    }

    # Record move.
    $move = {};
    $move->{CMD} = $cmd;
    $move->{REPLY} = $reply;
    push(@moves, $move);

    last if eof;
}

### Stage 2 -- scan moves for those which mark or change location.

foreach $move (@moves) {
    undef $roomflag;
    undef $descflag;

    for (@{$move->{REPLY}}) {
	$blank = /^\s*$/;

	# Check for location title.
	if (!$roomflag && !$blank && &location($_)) {
	    $roomflag++;
	    $name = $_;
	    next;
	}

	# Check for room description.
	if ($roomflag && !$blank) {
	    undef $desc unless $descflag;
	    $desc .= "# " . $_ . "\n";
	    $descflag++;
	    next;
	}

	# Check for end of description.
	last if $descflag && $blank;
    }

    # Store room info (if any).
    if ($roomflag) {
	$move->{ROOM} = $name;
	$move->{DESC} = $desc if $desc;
	$move->{LOOK} = 1 if $move->{CMD} =~ /$re_look/o;
    }
}

### Stage 3 -- Build IFM room and link lists.

foreach $move (@moves) {
    $name = $move->{ROOM};
    $desc = $move->{DESC};

    # Skip it if no room is listed.
    next unless $name;

    # If it's a LOOK command, or we don't know where we are yet,
    # set current location.
    if ($move->{LOOK} || !$here) {
	$here = &newroom($name, $desc) unless $here;
	next;
    }

    # Otherwise, assume we moved in some way.  Try to find the new room.
    $there = &findroom($name, $desc);

    # If the new location looks like this one, do nothing.
    next if $there eq $here;

    # Get the movement direction.
    $cmd = $move->{CMD};

    if      ($cdirmap{$cmd}) {
	# Standard compass direction.
	$dir = $cdirmap{$cmd};
	undef $go;
	undef $cmd;
    } elsif ($odirmap{$cmd}) {
	# Other direction.
	$dir = &choosedir($here);
	$go = $odirmap{$cmd};
	undef $cmd;
    } else {
	# Weird direction.
	$dir = &choosedir($here);
	undef $go;
    }

    if (!$there) {
	# Unvisited -- new room.
	$here = &newroom($name, $desc, $dir, $here, $go, $cmd);
    } else {
	# Visited before -- new link.
	&newlink($here, $there, $dir, $go, $cmd);
	$here = $there;
    }
}

### Stage 4 -- Write IFM output.

print "## IFM map created from a transcript by $0\n";
print "## You will probably need to edit this further!\n";

print "\ntitle \"$opt_t\";\n" if $opt_t;

print "\n## Rooms generated by transcript.\n";

foreach $room (@rooms) {
    $name = $room->{NAME};
    $desc = $room->{DESC};
    $tag = $room->{TAG};
    $dir = $room->{DIR};
    $from = $room->{FROM};
    $go = $room->{GO};
    $cmd = $room->{CMD};

    print "room \"$name\" tag $tag";

    print " dir $dir" if $dir;
    print " from $from" if $from;
    print " go $go" if $go;
    print " cmd \"$cmd\"" if $cmd;

    print ";\n";

    print $desc, "\n" if $opt_v && $desc;
}

print "\n## Extra links generated by transcript.\n" if @links > 0;

foreach $link (@links) {
    $from = $link->{FROM};
    $to = $link->{TO};
    $tag = $link->{TAG};
    $dir = $link->{DIR};
    $go = $link->{GO};
    $cmd = $link->{CMD};

    print "link $from to $to";
    print " tag $tag" if $tag;
    print " dir $dir" if $dir;
    print " go $go" if $go;
    print " cmd \"$cmd\"" if $cmd;

    print ";\n";
}

if (@ifmcmds > 0) {
    print "\n## Included IFM commands.\n";
    print @ifmcmds;
}

# Return whether a text line looks like a location title.
sub location {
    my $line = shift;

    # Quick check for invalid chars.
    return 0 if $line =~ /[.!?]/;

    # Check word count.
    my @words = split(' ', $line);
    return 0 if @words > 8;

    # Check uncapitalized words.
    for (@words) {
	return 0 if /^[a-z]/ && length() > 3;
    }

    return 1;
}

# Add a new room to the room list.
sub newroom {
    my ($name, $desc, $dir, $from, $go, $cmd) = @_;
    my $tag = &maketag($name);

    my $room = {};
    push(@rooms, $room);

    $room->{NAME} = $name;
    $room->{DESC} = $desc;
    $room->{TAG} = $tag;

    $room->{DIR} = $dir if $dir;
    $room->{FROM} = $from if $from;
    $room->{GO} = $go if $go;
    $room->{CMD} = $cmd if $cmd;

    $roommap{$tag} = $room;

    push(@{$namemap{$name}}, $tag);
    push(@{$descmap{$desc}}, $tag);

    $roommap{$from}{$dir} = $tag if $from && $dir;

    return $tag;
}

# Add a new link to the link list if required.
sub newlink {
    my ($from, $to, $dir, $go, $cmd) = @_;

    # Check link doesn't already exist.
    return if $roommap{$from}{$dir} eq $to;

    # Check reverse link doesn't exist.
    my $rdir = $rdirmap{$dir};
    return if $roommap{$to}{$rdir} eq $from;

    # Add new link.
    my $link = {};
    push(@links, $link);

    $link->{FROM} = $from;
    $link->{TO} = $to;
    $link->{TAG} = $from . "_" . $to;
    $link->{DIR} = $dir if $dir;
    $link->{GO} = $go if $go;
    $link->{CMD} = $cmd if $cmd;

    $roommap{$from}{$dir} = $to;
}

# Return room tag given a name and description.
sub findroom {
    my ($name, $desc) = @_;
    my $list;

    # Prefer to decide by description.
    if ($desc) {
	$list = $descmap{$desc};
	for (@$list) {
	    return $_ if $name eq $roommap{$_}{NAME};
	}
    }

    $list = $namemap{$name};
    return $list->[0] if $list;

    return undef;
}

# Return room that a link links to.
sub findlink {
    my ($tag, $dir) = @_;
    return $roomtag{$tag}{$dir};
}

# Choose a direction to represent up/down/in/out.
sub choosedir {
    # At the moment, do something pig-ignorant.
    return "e";
}

# Make a room tag from its name.
sub maketag {
    my $name = shift;
    my $prefix;

    # Build prefix from initials of capitalized words.
    for (split(' ', $name)) {
	$prefix .= $1 if /^([A-Z])/;
    }

    # Make it unique.
    my $tag = $prefix;
    my $num = 1;
    while ($tagused{$tag}) {
	$tag = $prefix . ++$num;
    }

    $tagused{$tag}++;
    return $tag;
}

# Print a usage message and exit.
sub usage {
    print "Usage: $0 [options] [file]\n\n";
    print "   -t title       add a title\n";
    print "   -i file        include ifm commands from file\n";
    print "   -o file        write to given file\n";
    print "   -v             verbose mode\n";

    exit 0;
}
