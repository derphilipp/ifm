* IFM to-do list

** Next distribution

Document new stuff.

Add vars to control dot output.

Fix etags in progs dir.

Task text output: merge multiple identical tasks into one, with (%d times)
appended.

Maybe prepend $(pkgdatadir)/site-ifm directory to search path, to allow for
customization.  Create that dir when installing.

All new variables need testing somehow.  Create some test cases.

** Problems

Win32: doesn't install properly -- doesn't add .exe suffix.

Fix bugs with zork1.ifm: postscript output is weird.

Problem with PostScript room/item text filling -- see Attic in zorkzero.

tkifm accelerators don't work on Unix.

Nasty bug with 'leave': see leave-bug.ifm.  How to fix it?  One possibility
is to warn about it when doing movement -- if you ever move where you
shouldn't be allowed to.  But then again... how about, in find_path(),
keeping track of items that have to be left.  Then, in need-item check, can
see if it had to be dropped.  If first find_path() fails and at least one
LEAVE item was NEEDed, do find_path() again, pretending that the task in
question needs those items.

** General

Have -set option, to set variables on the command line (which override
settings in the input).

How about option to print map stats (sections and their sizes)?  Could be
useful for setting up map vars properly.

How about simple 'ifdef/elif/else/endif' syntax?  Depending on whether vars
are defined or not.  Or instead: 'if <var>' clause on things, which means
only add them if <var> is defined.  Could maybe implement ifdef stuff with
scanner in a different state.  Need a stack, I think, to implement nested
ifs.

Joining multiple rooms in a single command: isn't there a problem with join
tags?

Parser: how about 'them' (refers to the last list of IDs).

Have more specific compile error messages.  Or record character number, for
more accurate error location.

Simplify driver interface.  It's a mess.  Maybe remove dependence on Vars
knowledge.

** Styles

Get load_styles() to return success flag.

** Maps

How about a 'label' keyword, like rooms, that puts arbitrary text on the
page (like admap does)?  Specify its offset from a given room, its
dimensions and its anchor.  Calculate the room boxes it occupies, and give
warning if anything overlaps it.  Take text size into account when
calculating map size.  What's the best way to input N lines of text though?
Just consecutive strings?  Attributes: width, height, anchor, dir, from,
style.  Generalize put_room_at() to accept things apart from rooms
(labels).  With labels, the dir clause is mandatory.

Have general external room labels, at compass points.  Mark up/down/in/out
using them.

Add syntax to allow changing of join text (by default, it's an increasing
number).  Add warning if two join texts are the same.  Only allow join text
with explicit 'join' command.

Add 'show_exit_arrows' variable.  Arrow size controlled same as other
arrows.

Add 'show_joins' variable.  Default 1.

Need some sort of debugging feature that eases sorting out of overlapping
stuff.

How about OpenGL driver?  NT users get the OpenGL DLL free, apparently.

How about GD map driver?

How about GTK driver?

** Items

How about item flag: actor, which indicates that when got, they're
following you -- you don't pick them up.  So they shouldn't count in
inventory management.

** Tasks

How about 'after all' on tasks, which means 'do it last'?

How about inventory max-carried stuff?  Need to give each item a
'drop-priority' number (if two equal, use order of declaration) and a
weight.  Need to give player a max-carried number somehow.  Have 'sack'
attribute on items too -- if you've got one of those, max-carried doesn't
apply.  When just about to pick something up that would put you over the
limit, drop items in priority order until carry limit is ok.  But when to
pick them up again?  Need to do a 'drop-until' -- but until what task?
Until the next task to be done with the item you're about to pick up?
Maybe make 'get' tasks that would put you over the limit *very* low
priority -- only done if nothing else can be.

How about task 'do' attr, which flags other tasks as done too?  Might allow
multiple solutions.  But does it do all the other task's actions too
(losing items, dropping, etc)?  I think it must.

Maybe item 'need' list implies that the needed item can't be dropped until
that item is.

Is there a way to indicate that 'leave' items aren't explicitly dropped
without resorting to item 'lost' attr?  If so, can probably phase it out.
Maybe rename it to 'dropped'?  Or better, maybe have 'drop' synonym for
'leave', which flags those items as dropped at those places.

How about task 'before' attribute, for symmetry?

Test room note output in task list.  Problem with that: if start room has
note, you may never see it.  Ditto for other start room attrs.  Need
special start room 'task'.

Maybe have general events.  Have 'start of game' event that tells you where
you start from.  Change 'task step' to 'goal'.  Have global current-room.
Change T_<attr> to G_<attr>, and T_USER to G_DO.

How about Dave's item-state idea?

** Tests

Need more of them.

** PostScript driver

Implement 'link_spline' using curveto, if poss.

How about support for generic EPS file backgrounds?

Make overlapping stuff look less cryptic.

What about poster output?  Could have poster_width and poster_height
variables (integers), which magnify the page dimensions by these factors
and invoke the printposter function on each page (with its page dimensions
set to original page size minus poster_margin).  That way, could do an A3
poster (or whatever) too.  Not quite that simple though.  Work out poster
dimensions from poster single-page size and the size of the poster.  Have
'poster_print' var to turn poster on.  Specify poster single-page size in
same manner as normal page size.

Fix roomitemratio like Tk version.  Maybe have this as a control var.

** Text driver

Implement note filling.  Have variable 'text_wrap_column' (default 75).
Problem: tk uses text to get items/tasks.  But you can't specify a separate
tk value for this var, cos text output won't use it.  So you can't make
window width correspond to this var value.  Possible solution: allow
setting of vars globally on the command line, which overrides all settings
in files.

Someone suggested having text map driver.  Yuck!  But it might be possible
to do nicely.  (1) build title (and optional item list) strings per room
(2) count max word size, x it by constant to give room width (3) split text
lines on that width (4) calc room height = max no. of lines (+1 blank if
item list) (5) build text array and draw everything with special chars
(definable) (6) print it.  All this is per map section.

Alternatively: get it to use existing vars as much as possible, for
consistency.  But room_size is in cm, so can't be used.  Need
room_char_size or something.  Also need some width/height ratio variable so
that if room_width and room_height are the same, the box looks square on
output.

** Raw driver

** Recording driver

** Tcl/Tk driver

Do line clipping here instead of in tkifm.  Make clipping standard across
drivers, using the util function.  In fact, have clipped version of lines
before drivers even see them (but keep originals for raw output).

** Tkifm

Gather all warnings/errors and display them at once in a text window.
Enable single-click which goes to that line number (if any) in edit
window.  Don't exit IFM after first error.

Add horizontal scrollbars to text windows.  Don't wrap words.

Get it to read a standard init like ifm does, by using standard search path
or IFMPATH.  Can keep doc up to date properly then.

.ifm suffix is assumed.  Change doc to reflect this.

Maybe all the non-line-specific errors and warnings should be bunched
together in a single message.  Or get error/warning funcs to ask if user
wants to skip rest of messages.

How about dump-window-to-ps option, using canvas ps command?

** Scr2ifm

How about a general perl module for building ifm input?  Methods:
    room(desc, args)	define a new room (returns id)
    findroom(tag)	return room with given tag
    link(from, to, args) define a new link (returns id)
    findlink(tag)	ditto
    cmd(str)		arbitrary command
    write(handle)	output it

Recognize oneway links?

More options controlling output (e.g. tags, items, tasks, etc.).

Maybe phase out vars altogether and replace with commands.

Add command stripping regexp (eg to dispose of 'go').

** Rec2scr

How about using the innate script facility of dumb-frotz instead of
capturing stdout?  Or maybe an option to that effect.

The cmd command don't seem to want to print RETURN.

** IFM maps

lgop: add scratch 'n' sniff stuff.

lgop: implement alternative flytrap solution (hiss).

** Documentation

Index needs improving.

Document output of -debug option.

Write doc about how to add drivers (need vars know-how).

Add history/future directions section?
